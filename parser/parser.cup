package parser;

import java_cup.runtime.*;
import ast.*;
import java.util.*;

/* Parser code */
parser code {:
    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error at line " + cur_token.left + 
                     ", column " + cur_token.right + 
                     ", unexpected token: " + cur_token.value, null);
    }

    public void report_error(String message, Object info) {
        System.err.println(message);
    }
    
    public void unrecovered_syntax_error(Symbol cur_token) {
        System.err.println("Fatal syntax error at line " + cur_token.left + 
                          ", column " + cur_token.right);
        System.exit(1);
    }
:};

/* Terminals (tokens) */
terminal CONFIG, BASE_URL, HEADER, LET, TEST;
terminal GET, POST, PUT, DELETE;
terminal EXPECT, STATUS, BODY, CONTAINS;
terminal EQUALS, SEMICOLON, LBRACE, RBRACE;
terminal String IDENTIFIER, STRING;
terminal Integer NUMBER;

/* Non-terminals */
non terminal ProgramNode program;
non terminal ConfigNode config_opt, config_block;
non terminal List config_items;
non terminal List variables;
non terminal VariableNode variable;
non terminal Object value;
non terminal List tests;
non terminal TestNode test_block;
non terminal List test_statements;
non terminal Object test_statement;
non terminal RequestNode request;
non terminal List request_block_opt, request_items;
non terminal Object request_item;
non terminal HeaderNode header_decl;
non terminal AssertionNode assertion;

/* Precedence (not needed for this grammar) */

/* Grammar Rules */
start with program;

/* Program: config? variables* tests+ */
program ::= 
    config_opt:c variables:v tests:t
    {: 
        ProgramNode prog = new ProgramNode();
        if (c != null) {
            prog.setConfig(c);
        }
        for (Object var : v) {
            prog.addVariable((VariableNode) var);
        }
        for (Object test : t) {
            prog.addTest((TestNode) test);
        }
        RESULT = prog;
    :}
    ;

/* Config block (optional) */
config_opt ::= 
    config_block:c          {: RESULT = c; :}
    | /* empty */           {: RESULT = null; :}
    ;

config_block ::= 
    CONFIG LBRACE config_items:items RBRACE
    {:
        ConfigNode config = new ConfigNode();
        for (Object item : items) {
            if (item instanceof String) {
                config.setBaseUrl((String) item);
            } else if (item instanceof HeaderNode) {
                config.addHeader((HeaderNode) item);
            }
        }
        RESULT = config;
    :}
    ;

config_items ::=
    config_items:list BASE_URL EQUALS STRING:url SEMICOLON
    {:
        list.add(url);
        RESULT = list;
    :}
    | config_items:list header_decl:h
    {:
        list.add(h);
        RESULT = list;
    :}
    | /* empty */
    {:
        RESULT = new ArrayList();
    :}
    ;

header_decl ::=
    HEADER STRING:key EQUALS STRING:val SEMICOLON
    {:
        RESULT = new HeaderNode(key, val);
    :}
    ;

/* Variables: let name = value; */
variables ::=
    variables:list variable:v
    {:
        list.add(v);
        RESULT = list;
    :}
    | /* empty */
    {:
        RESULT = new ArrayList();
    :}
    ;

variable ::=
    LET IDENTIFIER:name EQUALS value:val SEMICOLON
    {:
        RESULT = new VariableNode(name, val);
    :}
    ;

value ::=
    STRING:s        {: RESULT = s; :}
    | NUMBER:n      {: RESULT = n; :}
    ;

/* Tests: test Name { ... } */
tests ::=
    tests:list test_block:t
    {:
        list.add(t);
        RESULT = list;
    :}
    | test_block:t
    {:
        List list = new ArrayList();
        list.add(t);
        RESULT = list;
    :}
    ;

test_block ::=
    TEST IDENTIFIER:name LBRACE test_statements:stmts RBRACE
    {:
        TestNode test = new TestNode(name);
        for (Object stmt : stmts) {
            if (stmt instanceof RequestNode) {
                test.addRequest((RequestNode) stmt);
            } else if (stmt instanceof AssertionNode) {
                test.addAssertion((AssertionNode) stmt);
            }
        }
        RESULT = test;
    :}
    ;

test_statements ::=
    test_statements:list test_statement:stmt
    {:
        list.add(stmt);
        RESULT = list;
    :}
    | test_statement:stmt
    {:
        List list = new ArrayList();
        list.add(stmt);
        RESULT = list;
    :}
    ;

test_statement ::=
    request:r           {: RESULT = r; :}
    | assertion:a       {: RESULT = a; :}
    ;

/* HTTP Requests */
request ::=
    GET STRING:path SEMICOLON
    {:
        RESULT = new RequestNode(RequestNode.HttpMethod.GET, path);
    :}
    | DELETE STRING:path SEMICOLON
    {:
        RESULT = new RequestNode(RequestNode.HttpMethod.DELETE, path);
    :}
    | POST STRING:path request_block_opt:items SEMICOLON
    {:
        RequestNode req = new RequestNode(RequestNode.HttpMethod.POST, path);
        for (Object item : items) {
            if (item instanceof HeaderNode) {
                req.addHeader((HeaderNode) item);
            } else if (item instanceof String) {
                req.setBody((String) item);
            }
        }
        RESULT = req;
    :}
    | PUT STRING:path request_block_opt:items SEMICOLON
    {:
        RequestNode req = new RequestNode(RequestNode.HttpMethod.PUT, path);
        for (Object item : items) {
            if (item instanceof HeaderNode) {
                req.addHeader((HeaderNode) item);
            } else if (item instanceof String) {
                req.setBody((String) item);
            }
        }
        RESULT = req;
    :}
    ;

request_block_opt ::=
    LBRACE request_items:items RBRACE      {: RESULT = items; :}
    | /* empty */                          {: RESULT = new ArrayList(); :}
    ;

request_items ::=
    request_items:list request_item:item
    {:
        list.add(item);
        RESULT = list;
    :}
    | /* empty */
    {:
        RESULT = new ArrayList();
    :}
    ;

request_item ::=
    header_decl:h       {: RESULT = h; :}
    | BODY EQUALS STRING:s SEMICOLON    {: RESULT = s; :}
    ;

/* Assertions */
assertion ::=
    EXPECT STATUS EQUALS NUMBER:code SEMICOLON
    {:
        RESULT = new AssertionNode(AssertionNode.AssertionType.STATUS, code);
    :}
    | EXPECT HEADER STRING:key EQUALS STRING:val SEMICOLON
    {:
        RESULT = new AssertionNode(AssertionNode.AssertionType.HEADER_EQUALS, key, val);
    :}
    | EXPECT HEADER STRING:key CONTAINS STRING:val SEMICOLON
    {:
        RESULT = new AssertionNode(AssertionNode.AssertionType.HEADER_CONTAINS, key, val);
    :}
    | EXPECT BODY CONTAINS STRING:val SEMICOLON
    {:
        RESULT = new AssertionNode(AssertionNode.AssertionType.BODY_CONTAINS, val);
    :}
    ;